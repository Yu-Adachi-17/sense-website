require('dotenv').config();
console.log("‚úÖ STRIPE_SECRET_KEY:", process.env.STRIPE_SECRET_KEY ? "Loaded" : "Not found");
console.log("‚úÖ STRIPE_PRICE_UNLIMITED:", process.env.STRIPE_PRICE_UNLIMITED ? "Loaded" : "Not found");

const express = require('express');
const multer = require('multer');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const ffmpeg = require('fluent-ffmpeg');
const cors = require('cors');
const FormData = require('form-data');
const Stripe = require('stripe'); // Stripe„É©„Ç§„Éñ„É©„É™„ÅÆ„Ç§„É≥„Éù„Éº„Éà
const app = express();

app.use(express.json()); // ‚úÖ JSON„É™„ÇØ„Ç®„Çπ„Éà„Çí„Éë„Éº„Çπ

// ‚úÖ Ë®±ÂèØ„Åô„Çã„Ç™„É™„Ç∏„É≥„ÇíÂÆöÁæ©
const allowedOrigins = ['https://sense-ai.world', 'https://www.sense-ai.world'];

// ‚úÖ „Åô„Åπ„Å¶„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„Å´ CORS „ÇíÈÅ©Áî®
const corsOptions = {
    origin: (origin, callback) => {
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            console.error(`[CORS ERROR] Ë®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Ç™„É™„Ç∏„É≥: ${origin}`);
            callback(new Error('Not allowed by CORS'));
        }
    },
    methods: ['GET', 'POST', 'OPTIONS'], // Ë®±ÂèØ„Åô„ÇãHTTP„É°„ÇΩ„ÉÉ„Éâ
    allowedHeaders: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With'], // Ë®±ÂèØ„Åô„Çã„Éò„ÉÉ„ÉÄ„Éº
    credentials: true // Cookie„ÇÑË™çË®ºÊÉÖÂ†±„ÇíË®±ÂèØ
};
app.use(cors(corsOptions));

// ‚úÖ „Åô„Åπ„Å¶„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Å´ CORS „Éò„ÉÉ„ÉÄ„Éº„ÇíÂº∑Âà∂ÈÅ©Áî®
app.use((req, res, next) => {
    const origin = req.headers.origin;
    if (allowedOrigins.includes(origin)) {
        res.header('Access-Control-Allow-Origin', origin);
    }
    res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Accept, X-Requested-With');
    res.header('Access-Control-Allow-Credentials', 'true');
    if (req.method === 'OPTIONS') {
        return res.sendStatus(204); // „Éó„É™„Éï„É©„Ç§„Éà„É™„ÇØ„Ç®„Çπ„Éà„Å´„ÅØ„Çπ„ÉÜ„Éº„Çø„Çπ204„ÇíËøî„Åô
    }
    next();
});

// ‚úÖ OPTIONS „É°„ÇΩ„ÉÉ„ÉâÔºà„Éó„É™„Éï„É©„Ç§„Éà„É™„ÇØ„Ç®„Çπ„ÉàÔºâ„Å∏„ÅÆÂØæÂøú
app.options('*', (req, res) => {
    console.log('[DEBUG] „Éó„É™„Éï„É©„Ç§„Éà„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂèó‰ø°:', req.headers);
    const origin = req.headers.origin;
    if (allowedOrigins.includes(origin)) {
        res.header('Access-Control-Allow-Origin', origin);
    }
    res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Accept, X-Requested-With');
    res.header('Access-Control-Allow-Credentials', 'true');
    res.sendStatus(204); // „Éó„É™„Éï„É©„Ç§„Éà„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂá¶ÁêÜ
});


// ‚úÖ „Éá„Éê„ÉÉ„Ç∞Áî®„É≠„Ç∞„ÇíËøΩÂä†
app.use((req, res, next) => {
    console.log(`[DEBUG] „É™„ÇØ„Ç®„Çπ„ÉàË©≥Á¥∞:
  - „É°„ÇΩ„ÉÉ„Éâ: ${req.method}
  - „Ç™„É™„Ç∏„É≥: ${req.headers.origin || 'Êú™Ë®≠ÂÆö'}
  - „Éë„Çπ: ${req.path}
  - „Éò„ÉÉ„ÉÄ„Éº: ${JSON.stringify(req.headers, null, 2)}
`);
    next();
});



// ‚úÖ Multer„ÅÆË®≠ÂÆöÔºà100MB„Åæ„Åß„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂèó„Åë‰ªò„Åë„ÇãÔºâ
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 100 * 1024 * 1024 } // 100MB„Åæ„ÅßOK
});

// ‚úÖ OpenAI API„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
const OPENAI_API_ENDPOINT_TRANSCRIPTION = 'https://api.openai.com/v1/audio/transcriptions';
const OPENAI_API_ENDPOINT_CHATGPT = 'https://api.openai.com/v1/chat/completions';

// ‚úÖ Stripe„ÅÆÂàùÊúüÂåñ
const stripe = Stripe(process.env.STRIPE_SECRET_KEY); // Railway„Å´„Çª„ÉÉ„Éà„Åó„Åü„Ç≠„Éº„Çí‰ΩøÁî®

// ‚úÖ ChatGPT„Çí‰ΩøÁî®„Åó„Å¶Ë≠∞‰∫ãÈå≤„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
const generateMinutes = async (transcription) => {
    const data = {
        model: 'gpt-4',
        messages: [
            { role: 'system', content: '„ÅÇ„Å™„Åü„ÅØÂÑ™ÁßÄ„Å™Ë≠∞‰∫ãÈå≤‰ΩúÊàê„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ‰ª•‰∏ã„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂü∫„Å´Ë≠∞‰∫ãÈå≤„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ' },
            { role: 'user', content: transcription },
        ],
        max_tokens: 2000,
        temperature: 0.5,
    };

    try {
        console.log('[DEBUG] Sending data to ChatGPT API:', data);
        const response = await axios.post(OPENAI_API_ENDPOINT_CHATGPT, data, {
            headers: {
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                'Content-Type': 'application/json',
            },
            timeout: 600000, // 10ÂàÜ
        });
        console.log('[DEBUG] ChatGPT API response:', response.data);
        return response.data.choices[0].message.content.trim();
    } catch (error) {
        console.error('[ERROR] ChatGPT API failed:', error.response?.data || error.message);
        throw new Error('ChatGPT API „Å´„Çà„ÇãË≠∞‰∫ãÈå≤ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
};

// ‚úÖ Whisper API„Çí‰ΩøÁî®„Åó„Å¶ÊñáÂ≠óËµ∑„Åì„Åó„ÇíË°å„ÅÜÈñ¢Êï∞
const transcribeWithOpenAI = async (filePath) => {
    try {
        const formData = new FormData();
        formData.append('file', fs.createReadStream(filePath));
        formData.append('model', 'whisper-1');

        console.log(`[DEBUG] Sending file to Whisper API: ${filePath}`);

        const response = await axios.post(OPENAI_API_ENDPOINT_TRANSCRIPTION, formData, {
            headers: {
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                ...formData.getHeaders(),
            },
            timeout: 600000,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
        });

        console.log('[DEBUG] Whisper API response:', response.data);
        return response.data.text;
    } catch (error) {
        console.error('[ERROR] Whisper API error:', error.response?.data || error.message);
        throw new Error('Whisper API „Å´„Çà„ÇãÊñáÂ≠óËµ∑„Åì„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
};

// ‚úÖ `/api/transcribe` „ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊòéÁ§∫ÁöÑ„Å´Á¢∫Ë™ç
console.log('[DEBUG] Registering /api/transcribe route');

// ‚úÖ „Éá„Éê„ÉÉ„Ç∞Áî®„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØAPI
app.get('/api/health', (req, res) => {
    console.log('[DEBUG] /api/health was accessed');
    res.status(200).json({ status: 'OK', message: 'Health check passed!' });
});



// ‚úÖ „Åô„Åπ„Å¶„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„Çí„É≠„Ç∞Âá∫Âäõ
app.use((req, res, next) => {
    console.log(`[DEBUG] „É™„ÇØ„Ç®„Çπ„ÉàÂèó‰ø°: ${req.method} ${req.path}`);
    next();
});


// ‚úÖ API„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÂÆöÁæ©
app.get('/api/hello', (req, res) => {
    res.json({ message: "Hello from backend!" });
});

app.post('/api/transcribe', upload.single('file'), async (req, res) => {
    console.log('[DEBUG] /api/transcribe called');

    try {
        const file = req.file;
        if (!file) {
            console.error('[ERROR] „Éï„Ç°„Ç§„É´„Åå„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
            return res.status(400).json({ error: '„Éï„Ç°„Ç§„É´„Åå„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì' });
        }

        console.log(`[DEBUG] File received: ${file.originalname}`);
        const tempDir = path.join(__dirname, 'temp');
        if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
        }

        const tempFilePath = path.join(tempDir, `${Date.now()}_${file.originalname}`);
        fs.writeFileSync(tempFilePath, file.buffer);
        console.log('[DEBUG] File saved temporarily at:', tempFilePath);

        let transcription;
        try {
            transcription = await transcribeWithOpenAI(tempFilePath);
            console.log('[DEBUG] Transcription result:', transcription);
        } catch (error) {
            console.error('[ERROR] Whisper API failed:', error);
            return res.status(500).json({ error: 'Whisper API „Å´„Çà„ÇãÊñáÂ≠óËµ∑„Åì„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü' });
        }

        fs.unlinkSync(tempFilePath);

        let minutes;
        try {
            minutes = await generateMinutes(transcription.trim());
            console.log('[DEBUG] ChatGPT result:', minutes);
        } catch (error) {
            console.error('[ERROR] ChatGPT API failed:', error);
            return res.status(500).json({ error: 'ChatGPT API „Å´„Çà„ÇãË≠∞‰∫ãÈå≤ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü' });
        }

        res.json({ transcription: transcription.trim(), minutes });

    } catch (error) {
        console.error('[ERROR] /api/transcribe internal error:', error);
        res.status(500).json({ error: '„Çµ„Éº„Éê„ÉºÂÜÖÈÉ®„Ç®„É©„Éº' });
    }
});
// ‚úÖ „Éá„Éê„ÉÉ„Ç∞Áî®„Å´ GET /api/transcribe „ÇíËøΩÂä†
app.get('/api/transcribe', (req, res) => {
    res.json({ message: "API is working!" });
});
app.get('/api/transcribe', (req, res) => {
    res.status(200).json({ message: 'GET /api/transcribe is working!' });
});
app.post('/api/transcribe', (req, res) => {
    res.status(200).json({ message: 'API is working!' });
});

// ‚úÖ Stripe Checkout Session‰ΩúÊàê„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÅÆËøΩÂä†
app.post('/api/create-checkout-session', async (req, res) => {
    try {
        const { productId } = req.body;
        console.log("‚úÖ Âèó‰ø°„Åó„Åü productId:", productId); // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞

        // üî• Áí∞Â¢ÉÂ§âÊï∞„Éû„ÉÉ„Éî„É≥„Ç∞
        const PRICE_MAP = {
            [process.env.STRIPE_PRODUCT_UNLIMITED]: process.env.STRIPE_PRICE_UNLIMITED,
            [process.env.STRIPE_PRODUCT_120MIN]: process.env.STRIPE_PRICE_120MIN,
            [process.env.STRIPE_PRODUCT_1200MIN]: process.env.STRIPE_PRICE_1200MIN
        };

        const priceId = PRICE_MAP[productId];

        if (!priceId) {
            console.error("‚ùå productId „ÅåÁÑ°Âäπ:", productId);
            return res.status(400).json({ error: "Invalid productId" });
        }

        const session = await stripe.checkout.sessions.create({
            payment_method_types: ['card'],
            mode: productId === process.env.STRIPE_PRODUCT_UNLIMITED ? 'subscription' : 'payment',
            line_items: [{ price: priceId, quantity: 1 }],
            success_url: 'https://sense-ai.world/success',
            cancel_url: 'https://sense-ai.world/cancel',
        });

        console.log("‚úÖ Checkout URL:", session.url);
        res.json({ url: session.url });
    } catch (error) {
        console.error('[ERROR] /create-checkout-session:', error);
        res.status(500).json({ error: 'Checkout„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü' });
    }
});


// ‚úÖ „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅÆÈùôÁöÑ„Éï„Ç°„Ç§„É´„ÇíÊèê‰æõ
const staticPath = path.join(__dirname, 'frontend/build');
console.log(`[DEBUG] Static files served from: ${staticPath}`);
app.use(express.static(staticPath));

// ‚úÖ ÊúÄÂæå„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶React„ÇíËøî„ÅôÔºàAPI„É™„ÇØ„Ç®„Çπ„Éà„Åß„ÅØÈÅ©Áî®„Åó„Å™„ÅÑÔºâ
app.use('/api', (req, res, next) => {
    res.status(404).json({ error: 'API route not found' });
});

// ‚úÖ React „ÅÆ„É´„Éº„Éà (`/success` „Å™„Å©) „ÇíÊ≠£„Åó„Åè„Éè„É≥„Éâ„É™„É≥„Ç∞
app.get(["/success", "/cancel"], (req, res) => {
    res.sendFile(path.join(staticPath, "index.html"));
});

// ‚úÖ „Åù„ÅÆ‰ªñ„ÅÆÊú™ÂÆöÁæ©„É´„Éº„Éà„ÇÇ `index.html` „Å´„É™„ÉÄ„Ç§„É¨„ÇØ„Éà
app.get('*', (req, res) => {
    console.log(`[DEBUG] Redirecting ${req.url} to index.html`);
    res.sendFile(path.join(staticPath, "index.html"));
});


// ‚úÖ „Çµ„Éº„Éê„Éº„ÅÆËµ∑Âãï
const PORT = process.env.PORT || 5001; 
console.log(`[DEBUG] API Key loaded: ${process.env.OPENAI_API_KEY ? 'Yes' : 'No'}`);
app.listen(PORT, () => {
    console.log(`[DEBUG] „Çµ„Éº„Éê„Éº„Åå„Éù„Éº„Éà ${PORT} „ÅßËµ∑Âãï„Åó„Åæ„Åó„Åü`);
});

module.exports = app;
