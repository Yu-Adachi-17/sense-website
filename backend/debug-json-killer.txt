佐藤: じゃあ、今日の議題は「JSON がぶっ壊れやすいケース」の洗い出しね。"安全な文字列" なんて一旦忘れて、あえて危ない文字をバンバン入れていきたい。

田中: 了解です。たとえばさ、ユーザー名にこんなのが来たらどうする？
  name = "山田\"太郎"
  nickname = "tarou\yamada"
  comment = "昨日のログが { "status": "error", "message": "Unexpected token '}'" } って出てたんだけど…"
…みたいなやつ。今のままだと、このまま JSON に突っ込んだ瞬間に死にそうじゃない？

佐藤: そうそう。しかも実際には、発言ログとしてはこうなるはずなんだよね:
  「いや〜 "{"user":"taro","role":"admin"}" みたいな文字列がネストされてさ、しかも途中で改行入ってるんだよ…」
とか、
  「C:\Users\taro\Desktop\minutes\2025\11\test.json に保存したはずなんだけどさ」
とか。
これをそのまま
  "transcript": "……ここに全部ぶち込み……"
って JSON にすると、バックスラッシュとかダブルクォートで即アウト。

田中: じゃあ実験用に、わざとこんな断片を混ぜておこうか:

  - パス文字列:
      C:\Program Files\App\app.exe
      C:\Users\someone\Documents\project\minutes\raw\dummy\file_01.txt
  - 擬似 JSON 文字列:
      {"id": "12345", "title": "テスト", "note": "改行\n改行\n\"ダブルクォート\" も含むよ"}
      {"broken": true, "why": "末尾にカンマ, があるから",}
  - SQL っぽい文字列:
      SELECT * FROM users WHERE name = 'O\'Connor' AND note LIKE '%{"key":"value"}%';

佐藤: いいね。それに加えて、自然言語側でもこういうやつを混ぜたい。

  「でさ、実際のユーザーの一言コメントが
   『正直言って "めちゃくちゃ" 使いづらかったです。パスは C:\temp\log\error.log にあります』
   って来るじゃない？
   これを
   {
     "feedback": "正直言って "めちゃくちゃ" 使いづらかったです。パスは C:\temp\log\error.log にあります"
   }
   みたいに雑に入れると、その `"めちゃくちゃ"` のところで JSON が爆発する。」

田中: さらに、チャットボットの応答をそのまま残しておくケースもあるよね。

  assistant: 「では、次の JSON をコピペしてください:
  {
    "title": "テスト用\"タイトル\"",
    "lines": [
      "1行目: シンプルなテキスト",
      "2行目: C:\\logs\\2025\\11\\system\\error.log",
      "3行目: キー 'value' と \"value\" が混在"
    ]
  }
  以上です。」
  
これを transcript 全体に残した状態で minutes 生成プロンプトに突っ込んだら、モデルが
  {"meetingTitle":"…","sections":[{"title":"…","details":["…\"タイトル\"…"]}]}
みたいなの返してくる可能性があって、その中にさらに `{ "title": "テスト用\"タイトル\"" }` みたいな断片をネストしようとして地獄。

佐藤: そうそう、「\"」と「\\」の組み合わせが一番ヤバい。たとえば次の一文なんか完全に事故要因だよね:

  「バグ再現手順: アプリを起動 → "Export JSON" ボタンを押下 → 出力されたファイル (例: C:\Users\test\Desktop\export\minutes\2025\11\sample.json) を開く → 中身に {"key":"val\"ue","path":"C:\\Users\\test"} という行が含まれていることを確認」

田中: それだけじゃなくて、会議中に誰かがコード読み上げるパターンもある。

  「じゃあ実際のコード読み上げるね。function buildPayload() {
      return "{\\"status\\":\\"ok\\",\\"message\\":\\"done\\",\\"data\\":[1,2,3]}";
    } こういう感じでさ」
    
これ、音声から文字起こししたら LLM はだいたい
  return "{\"status\":\"ok\",\"message\":\"done\",\"data\":[1,2,3]}";
ってテキストを生成しがちなんだけど、そのまま JSON の value に入れると、バックスラッシュの数が曖昧で一気に壊れる。

佐藤: トドメとして、「カギ括弧が閉じてるんだか閉じてないんだか分からない長文」も入れておきたい。

  「えっと、さっきの仕様書には『ユーザーが "プロジェクトA(仮称)" に参加した場合、ロール "owner','editor','viewer' のいずれかを…」って書いてあったと思うんだけど、そのあとカッコがどこで閉じてるのかよく分からないんだよね、"owner','editor','viewer'" の並び順もバラバラでさ…」

田中: うん、それいいね。あと、この辺の断片も一緒に混ぜておこう。

  "生ログ例":
    [2025-11-26 10:15:23] INFO  user_id='abc123' action="login" ip="192.168.0.1"
    [2025-11-26 10:16:05] WARN  msg="unexpected value: \"N/A\"" payload="{\"retry\":true,\"count\":3}"

  "よくあるエラーメッセージ":
    SyntaxError: Unexpected token '\"' in JSON at position 128
    JSON.parse("{\"id\":1,\"name\":\"Taro\"\"}")

佐藤: ここまでぐちゃぐちゃなテキストを一つの transcript として突っ込んどいて、モデル側には
  - 「JSON で返せ」
  - 「キーは固定」
  - 「値には元のテキストを適当に要約して入れろ」
みたいなオーダーを出す、と。  
で、わざと
  ・ダブルクォート
  ・シングルクォート
  ・バックスラッシュ
  ・中括弧 / 角括弧
  ・パスやエラーメッセージ
を全部ミックスして、「ちょっとでもエスケープが甘いと JSON が即死する」状態を再現する、と。

田中: そう。人間から見るとただのカオスなメモなんだけど、パーサーと LLM と JSON の三重苦を一気に炙り出すための毒テキスト、って感じだね。
